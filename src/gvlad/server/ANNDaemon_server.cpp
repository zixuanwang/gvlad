// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "ANNDaemon.h"
#include <boost/bind.hpp>
#include <boost/lambda/lambda.hpp>
#include <boost/thread/mutex.hpp>
#include "gvlad/lib/Compressor.h"
#include "gvlad/lib/DetectorDescriptor.h"
#include "gvlad/lib/GeometricVerifier.h"
#include "gvlad/lib/KnnClassifier.h"
#include "gvlad/lib/Timer.h"
#include "gvlad/lib/Vocabulary.h"
#include <set>
#include <opencv2/nonfree/nonfree.hpp>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::concurrency;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace ::gvlad;

class ANNDaemonHandler: virtual public ANNDaemonIf {
public:
	ANNDaemonHandler(const std::string& feature_dir, bool ann_search) :
			m_classifier(ann_search) {
		std::vector<std::string> file_vector;
		File::get_files(file_vector, feature_dir, false);
		for (size_t i = 0; i < file_vector.size(); ++i) {
			std::string stem = File::get_stem(file_vector[i]);
			std::vector<float> feature;
			Serializer::load(feature, file_vector[i]);
			m_classifier.add_sample(feature, stem);
		}
		m_classifier.build();
		DetectorDescriptor::instance()->init("SURF", "SURF");
	}

	void query(std::vector<Neighbor> & _return, const std::string& image_path,
			const int32_t k) {
		std::vector<float> feature;
		compute_feature(feature, image_path);
		std::vector<std::string> label;
		std::vector<float> distance;
		compute_similar(label, distance, feature, k);
		_return.reserve(k);
		for (size_t i = 0; i < label.size(); ++i) {
			Neighbor neighbor;
			neighbor.id = label[i];
			neighbor.distance = (double) distance[i];
			_return.push_back(neighbor);
		}
	}

	void query(std::vector<std::string> & _return,
			const std::string& image_path, const int32_t k) {
		std::vector<float> feature;
		compute_feature(feature, image_path);
		compute_similar(_return, feature, k);
	}
private:
	class ParallelVerifier {
	public:
		ParallelVerifier(GeometricVerifier* pverifier,
				std::vector<std::string>* plabel,
				const std::string& descriptor_dir) {
			m_pverifier = pverifier;
			m_plabel = plabel;
			m_descriptor_dir = descriptor_dir;
		}
		void verify(size_t i) {
			GeoDescriptorVector<float> geo;
			geo.load(m_descriptor_dir + "/" + m_plabel->at(i) + ".geodesc");
			bool success = m_pverifier->verify(geo);
			boost::mutex::scoped_lock(m_mutex);
			if (success) {
				set.insert(i);
			}
		}
		std::set<size_t> set;
	private:
		boost::mutex m_mutex;
		GeometricVerifier* m_pverifier;
		std::vector<std::string>* m_plabel;
		std::string m_descriptor_dir;
	};
	KnnClassifier m_classifier;
	std::string m_descriptor_dir;
	void compute_descriptor(GeoDescriptorVector<float>& geo_descriptor_vector,
			const std::string& image_path) {
		cv::Mat img = cv::imread(image_path, 0);
		if (!img.empty()) {
			cv::Mat image;
			double s = 1024.0 / std::max(img.rows, img.cols);
			cv::resize(img, image, cv::Size(), s, s);
			DetectorDescriptor::instance()->compute_descriptor(image,
					geo_descriptor_vector);
		}
	}
	void compute_feature(std::vector<float>& feature,
			const std::string& image_path) {
		Timer timer;
		GeoDescriptorVector<float> geo_descriptor_vector;
		timer.start();
		compute_descriptor(geo_descriptor_vector, image_path);
		std::cout << "computing descriptors for " << image_path << " "
				<< geo_descriptor_vector.descriptor_count()
				<< " keypoints are detected... (" << timer.stop() << " ms)"
				<< std::endl;
		timer.start();
		Vocabulary::instance()->compute_gvlad(feature, geo_descriptor_vector);
		std::cout << "computing geometric vlad... (" << timer.stop() << " ms)"
				<< std::endl;
	}
	void compress_feature(std::vector<float>& compressed,
			const std::vector<float>& feature) {
		Timer timer;
		timer.start();
		Compressor::instance()->compress(compressed, feature);
		std::cout << "computing pca compression... (" << timer.stop() << " ms)"
				<< std::endl;
	}
	void compute_similar(std::vector<std::string>& result,
			const std::vector<float>& feature, int k) {
		Timer timer;
		timer.start();
		m_classifier.query(result, feature, k);
		std::cout << "computing nn searching... (" << timer.stop() << " ms)"
				<< std::endl;
	}
	void compute_similar(std::vector<std::string>& result,
			std::vector<float>& distance, const std::vector<float>& feature,
			int k) {
		Timer timer;
		timer.start();
		m_classifier.query(result, distance, feature, k);
		std::cout << "computing ann searching... (" << timer.stop() << " ms)"
				<< std::endl;
	}
};

int port;
std::string vocabulary;
std::string adaptation;
std::string feature_dir;

bool ann_search = false;

void exit_with_help() {
	std::cout
			<< "Usage: ANNDaemon [options] port vocabulary adaptation feature_dir\n"
					"options:\n"
					"-a approximate nearest neighbor search : (default 0)\n"
					"\t0 -- brute force search\t\t(accurate but slow)\n"
					"\t1 -- ANN search\t\t(FLANN is used)\n";
	exit(1);
}

void parse_command_line(int argc, char* argv[]) {
	int i;
	for (i = 1; i < argc; ++i) {
		if (argv[i][0] != '-')
			break;
		if (++i >= argc)
			exit_with_help();
		switch (argv[i - 1][1]) {
		case 'a':
			ann_search = atoi(argv[i]) == 1;
			break;
		default:
			std::cerr << "Unknown option: " << argv[i - 1][1] << std::endl;
			exit_with_help();
		}
	}
	if (i >= argc - 3)
		exit_with_help();
	port = atoi(argv[i++]);
	vocabulary = argv[i++];
	adaptation = argv[i++];
	feature_dir = argv[i];
}

int main(int argc, char* argv[]) {
	parse_command_line(argc, argv);
	cv::initModule_nonfree();
	Vocabulary::instance()->load(vocabulary);
	Vocabulary::instance()->load_adaptation(adaptation);
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
	shared_ptr<ANNDaemonHandler> handler;
	handler = shared_ptr<ANNDaemonHandler>(
			new ANNDaemonHandler(feature_dir, ann_search));
	shared_ptr<TProcessor> processor(new ANNDaemonProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(
			new TBufferedTransportFactory());
	shared_ptr<ThreadManager> threadManager =
			ThreadManager::newSimpleThreadManager(10);
	shared_ptr<PosixThreadFactory> threadFactory =
			shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
	threadManager->threadFactory(threadFactory);
	threadManager->start();
	TThreadPoolServer server(processor, serverTransport, transportFactory,
			protocolFactory, threadManager);
	std::cout << "server is ready..." << std::endl;
	server.serve();
	return 0;
}

